                    +---------------------------+
                    | CS 140                    |
                    | PROJECT 3: VIRTUAL MEMORY |
                    | DESIGN DOCUMENT           |
                    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.
None.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.
None.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

-- In thread.h --
Change struct thread:
struct thread
{
  bool is_user;                       /* Flag to identify whether the 
                                         thread is user process. */
  struct spt spt;                     /* Supplemental page table */
  struct mte *mt;                     /* Mmap table */
  int mt_size;                        /* Mmap table size */
  void *esp;                          /* User esp value at the initial
                                         transition from user to kernel*/
}

New struct mte:
/* Mmap table entry */
struct mte
{
  void *vaddr;                          /* The start addr of this map */
  size_t size;                          /* The mapped page count */
};


-- In swap.h --
New enum type:
/* flages for each frame entry */
enum frame_flags
{
    FRM_ASSERT = 0x1,           /* Panic on failure. */
    FRM_ZERO = 0x2,             /* Zero page contents. */
    FRM_USER = 0x4,             /* User page. */
    FRM_MMAP = 0x8              /* Page used for mmap. */
};

/* Frame table entry */
struct fte
{
  struct thread *thread;        /* Thread that owns this frame table entry. */
  uint32_t *pte;                /* The beginning virtual address that cooresponds
                                   to this frame table entry. */
  struct lock lock;             /* Per entry lock. */
};

/* Frame table */
struct frame_table
{
  size_t size;                  /* Total number of frames in this frame table */
  struct fte *frames;           /* Frames in the table */
  size_t clock_hand;            /* Clock hand for eviciton algorithm. */
  struct lock clock_lock;       /* Lock for clock_hand. */
};

struct frame_table frame_table; /* Global table used to check user memory. */

-- In swap.h --
New struct swap_table:
/* Swap talbe used to track used disk space. */
struct swap_table
{
  struct block *swap_block;    /* Swap block for paging. */
  struct bitmap *used_map;     /* Bitmap for free swap pages. */
  struct lock block_lock;      /* Lock to protect swap_block. */
  struct lock bitmap_lock;     /* Lock to protect used_map. */
};

struct swap_table swap_table;  /* Global table tracking swap frames in swap block. */

-- In page.h --
New struct file_meta:
/* file metadata for each mmap file*/
struct file_meta
{
  struct file *file;            /* pointer to a file structure */
  off_t offset;                 /* offset in the above file */
  size_t read_bytes;            /* total amount of bytes to read */
};

New union struct daddr:
/* union used by supplemental page table
 * entry to find corresponding files */
union daddr
{
  size_t swap_addr;             /* If this page is stored in as a swap page,
                                   swap_add indicates the slot num of the page
                                   in swap table */
  struct file_meta file_meta;   /* If the page is stored in disk as a mmap
                                   file, file_meta data stores necessary
                                   information to regain the page */
};

New struct spt:
/* supplemental page table */
struct spt
{
  struct hash table;            /* hash table to implement supplemental page
                                   table */
  struct lock lock;             /* lock for supplemental page table */
};

New struct spte:
/* supplemental page table entry*/
struct spte
{
  uint32_t *pte;                /* pointer to a page table entry*/
  union daddr daddr;            /* union used to find cooresponding file*/
  struct hash_elem elem;        /* element for hash table */
};

-- pte.h --
New flags for page table entry
#define PTE_FLAGS 0x00000fff    /* Flag bits. */
#define PTE_ADDR  0xfffff000    /* Address bits. */
#define PTE_AVL   0x00000e00    /* Bits available for OS use. */
#define PTE_P 0x1               /* 1=present, 0=not present. */
#define PTE_W 0x2               /* 1=read/write, 0=read-only. */
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_F 0x8               /* 1=comes from file, 0=in memory */
#define PTE_E 0x10              /* 1=comes from executable, 0=normal */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */
#define PTE_I 0x80              /* 1=pinned, 0=not pinned. */

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.


>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

