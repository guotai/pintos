                    +---------------------------+
                    | CS 140                    |
                    | PROJECT 3: VIRTUAL MEMORY |
                    | DESIGN DOCUMENT           |
                    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.
None.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.
None.

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

-- In thread.h --
Change struct thread:
struct thread
{
  bool is_user;                       /* Flag to identify whether the 
                                         thread is user process. */
  struct spt spt;                     /* Supplemental page table */
  struct mte *mt;                     /* Mmap table */
  int mt_size;                        /* Mmap table size */
  void *esp;                          /* User esp value at the initial
                                         transition from user to kernel*/
}

New struct mte:
/* Mmap table entry */
struct mte
{
  void *vaddr;                          /* The start addr of this map */
  size_t size;                          /* The mapped page count */
};

-- In page.h --
New struct file_meta:
/* file metadata for each mmap file*/
struct file_meta
{
  struct file *file;            /* pointer to a file structure */
  off_t offset;                 /* offset in the above file */
  size_t read_bytes;            /* total amount of bytes to read */
};

New union struct daddr:
/* union used by supplemental page table
 * entry to find corresponding files */
union daddr
{
  size_t swap_addr;             /* If this page is stored in as a swap page,
                                   swap_add indicates the slot num of the page
                                   in swap table */
  struct file_meta file_meta;   /* If the page is stored in disk as a mmap
                                   file, file_meta data stores necessary
                                   information to regain the page */
};

New struct spt:
/* supplemental page table */
struct spt
{
  struct hash table;            /* hash table to implement supplemental page
                                   table */
  struct lock lock;             /* lock for supplemental page table */
};

New struct spte:
/* supplemental page table entry*/
struct spte
{
  uint32_t *pte;                /* pointer to a page table entry*/
  union daddr daddr;            /* union used to find cooresponding file*/
  struct hash_elem elem;        /* element for hash table */
};

-- pte.h --
New flags for page table entry
#define PTE_FLAGS 0x00000fff    /* Flag bits. */
#define PTE_ADDR  0xfffff000    /* Address bits. */
#define PTE_AVL   0x00000e00    /* Bits available for OS use. */
#define PTE_P 0x1               /* 1=present, 0=not present. */
#define PTE_W 0x2               /* 1=read/write, 0=read-only. */
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_F 0x8               /* 1=comes from file, 0=in memory */
#define PTE_E 0x10              /* 1=comes from executable, 0=normal */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */
#define PTE_I 0x80              /* 1=pinned, 0=not pinned. */

---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.


>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

-- In frame.h --
New enum type:
/* flages for each frame entry */
enum frame_flags
{
    FRM_ASSERT = 0x1,           /* Panic on failure. */
    FRM_ZERO = 0x2,             /* Zero page contents. */
    FRM_USER = 0x4,             /* User page. */
    FRM_MMAP = 0x8              /* Page used for mmap. */
};

/* Frame table entry */
struct fte
{
  struct thread *thread;        /* Thread that owns this frame table entry. */
  uint32_t *pte;                /* The beginning virtual address that cooresponds
                                   to this frame table entry. */
  struct lock lock;             /* Per entry lock. */
};

/* Frame table */
struct frame_table
{
  size_t size;                  /* Total number of frames in this frame table */
  struct fte *frames;           /* Frames in the table */
  size_t clock_hand;            /* Clock hand for eviciton algorithm. */
  struct lock clock_lock;       /* Lock for clock_hand. */
};

struct frame_table frame_table; /* Global table used to check user memory. */

-- In swap.h --
New struct swap_table:
/* Swap talbe used to track used disk space. */
struct swap_table
{
  struct block *swap_block;     /* Swap block for paging. */
  struct bitmap *used_map;      /* Bitmap for free swap pages. */
  struct lock block_lock;       /* Lock to protect swap_block. */
  struct lock bitmap_lock;      /* Lock to protect used_map. */
};

struct swap_table swap_table;  /* Global table tracking swap frames in swap block. */

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We used clock algorithm for frame eviction. Each time the system need to 
evict a page, it iterate through the frames in frame_table starting from 
where the clock_hand was last time. For each frame, the algorithm go through 
the following checks until find an evictable frame.

(1) If the frame is pinned or the frame's lock is held by others, go on.
(2) If the frame/page is accessed recently (pte's PTE_A is set), reset the 
page's access bit and go on to next frame.
(3) If the frame is not accessed recently but dirty, write page back to file
if it's mmapped or write it to swap slot if it from exec. file or non-file, 
then set spte accordingly, reset dirty bit and go on to next frame.
(4) If the frame is neither accessed recently nor dirty, it's evictable. We
need to write it to a swap slot if the page is from non-file and set spte
accordingly. Now, a frame has been successfully evicted and free to use.

>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

In our design, each physical page in user pool is represented by a frame
table entry. Each frame table entry records the owner thread of the physical 
frame and the page table entry corresponding to it. Status of a page is 
stored in the last 12 bits (FLAGS) of its page table entry, i.e. whether it 
is a file page, an executable file page or a pinned page etc. From a thread's 
supplemental page table (a hash table) and its page's pte, we can find the 
page's spte, which stores the eviction related information such as the file 
source or swap slot number etc. 

                                SPTE, t->spt[index]
                               -----------------------
                        SPT - | uint32_t *pte         |
         FTE          /       | struct daddr daddr  - - -> swap slot or file
   ----------------- /        | struct hash_elem elem |
  | struct thread *t |         ---------------------- \
  | uint32_t *pte    |                                 | (hash)
   --------------- \-                PTE              /
                    \   -----------------------------
                     \ | 20bit PhyAddr | 12bit FLAGS |
                        -----------------------------

Firstly, process Q's corresponding virtual page is set as unpresent 
(i.e. PTE_P bit is 0) and the page is written back to file or swap slot if 
necessary. The address of the page in file or swap disk is recorded in 
the page's corresponding spte. Thus, next time the process Q's page is 
accessed a page fault will be trigured.

Secondly, the frame entry is modified to point to process P's page's PTE and
also owner thread becomes thread P.

>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.

---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)

The synchronization primitives we used are as following:
(1) Per thread supplemental page table lock. 
  Each thread has a suppl. page table and each SPT has a lock to realize 
  critical section for spte, especially to prevent non-atomic modificatons of 
  spte during evictions.
(2) Per entry frame table entry lock. 
  Each frame entry has a per-entry lock to prevent two threads from evicting 
  the same frame. Each time a thread examines a evicting candidate frame, the 
  frame is guarded by its FTE's lock.
(3) Global file system lock. 
  Each operation on file system, such as file open, file read, write or seek, 
  is protected by a single filesys_lock.
(4) Global pin lock. 
  Since PTE can be accessed in more than one place and by more than one thread, 
  a pin lock is used whenever we need to set or reset a page's PTE. It is also 
  used together with the pin cond.
(5) Global pin condition variable. 
  A page is pinned to prevent page faults occurances while a device driver 
  accesses a user bufferer passed to file_read, file_write etc. Once the 
  operation on the page is finished, the page is unpinned intermediately. 
  A conditional variable is used to avoid busy waiting for a pte pinning 
  operation.
(6) Swap table bitmap and block locks. 
  Two locks are used only inside swap.c methods to realize atomic operation 
  on the swap bitmap and swap block.
(7) Frame table clock_hand lock. 
  frame_table has a lock used solely for atmoic look up and increment of 
  clock_hand.

We prevent deadlock by eliminate circularity of requests and ownership. 
We set an fixed ordering of all lock acquires (lock releases are in inverse 
order). Lock (1) is always acquired first, (2) afterwards and (3) at last.
Locks (3)~(7) are lowest level locks, i.e. there is no lock acquires when a
thread holds any lock of (3)~(7).

>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

